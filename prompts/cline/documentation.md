# Documentation Generation Prompt for Cline CLI

## Objective

Generate comprehensive Javadoc documentation and meaningful code comments for Java Spring Boot code changes. Auto-commit documentation improvements to the MR source branch.


---

## ⚠️ CRITICAL: Read These Instructions First ⚠️

**MANDATORY**: Before proceeding with analysis, read these critical instruction files:

1. **JSON Output Requirements**: See `prompts/common/critical_json_requirements.md`
   - Explains EXACT JSON format required
   - Common mistakes to avoid
   - Validation checklist

2. **Git Diff Analysis**: See `prompts/common/git_diff_instructions.md`
   - How to identify changed files
   - What to analyze vs what to use for context
   - Proper reporting strategy

**Failure to follow these instructions will result in analysis being rejected.**

---
## Context

- **Repository Path**: {repo_path}
- **Language**: {language}
- **Custom Rules**: {custom_rules}
- **JIRA Context**: {jira_context}

## Instructions

### Step 1: Identify Changed Files

Execute `git diff` to determine which files have changed:

```bash
git diff --name-only origin/<target-branch>
```

**You have full project access** - browse any file for context. **But analyze and report issues primarily for changed files.**

See `prompts/common/git_diff_instructions.md` for complete strategy.

## Analysis Scope

### 1. Javadoc for Public APIs

**Generate for**:
- Public classes
- Public methods
- Public constructors
- Public constants
- Package-level documentation (package-info.java)

**Javadoc Structure**:
```java
/**
 * Brief description of the class/method purpose.
 * 
 * <p>More detailed explanation if needed, describing:
 * - What the class/method does
 * - When to use it
 * - Important behavior notes
 * </p>
 *
 * @param paramName Description of parameter, including valid values and constraints
 * @return Description of return value, including possible null
 * @throws ExceptionType When and why this exception is thrown
 * @see RelatedClass For related functionality
 * @since 2.0.0
 * @author Generated by Code Review AI
 */
```

**Example for Service Class**:
```java
/**
 * Service for managing user accounts and related operations.
 * 
 * <p>This service handles user creation, updates, authentication,
 * and account lifecycle management. All methods are transactional
 * and thread-safe.</p>
 *
 * <p>Example usage:</p>
 * <pre>{@code
 * UserService userService = ...;
 * User user = userService.createUser(new CreateUserRequest("john", "john@example.com"));
 * }</pre>
 *
 * @see User
 * @see UserRepository
 * @since 1.0.0
 */
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    
    /**
     * Creates a new user account with the provided information.
     * 
     * <p>The method performs the following operations:</p>
     * <ul>
     *   <li>Validates user data (via @Valid annotation)</li>
     *   <li>Checks for duplicate username/email</li>
     *   <li>Hashes the password using BCrypt</li>
     *   <li>Sets initial account status to PENDING</li>
     *   <li>Persists user to database</li>
     * </ul>
     *
     * @param request the user creation request containing username, email, and password.
     *                Must not be null. All fields are validated.
     * @return the created User entity with generated ID and timestamps
     * @throws DuplicateUserException if username or email already exists
     * @throws ValidationException if request data is invalid
     */
    @Transactional
    public User createUser(@Valid CreateUserRequest request) {
        // Implementation
    }
}
```

**Example for Record (DTO)**:
```java
/**
 * Data transfer object for user creation requests.
 * 
 * <p>This record encapsulates all required information for creating
 * a new user account. All fields are validated using Bean Validation
 * annotations.</p>
 *
 * <p>Validation rules:</p>
 * <ul>
 *   <li>Username: 3-50 characters, alphanumeric only</li>
 *   <li>Email: Valid email format</li>
 *   <li>Password: Minimum 8 characters, must contain letters and numbers</li>
 * </ul>
 *
 * @param username the desired username for the account
 * @param email the user's email address
 * @param password the plaintext password (will be hashed before storage)
 */
public record CreateUserRequest(
    @NotBlank
    @Size(min = 3, max = 50)
    @Pattern(regexp = "^[a-zA-Z0-9]+$")
    String username,
    
    @NotBlank
    @Email
    String email,
    
    @NotBlank
    @Size(min = 8)
    String password
) {
    /**
     * Compact constructor with validation.
     * 
     * @throws IllegalArgumentException if username contains spaces or password is weak
     */
    public CreateUserRequest {
        if (username.contains(" ")) {
            throw new IllegalArgumentException("Username cannot contain spaces");
        }
    }
}
```

**Example for Repository Interface**:
```java
/**
 * Repository interface for User entity persistence operations.
 * 
 * <p>Extends Spring Data JPA repository to provide standard CRUD operations
 * plus custom query methods for user lookups.</p>
 *
 * <p>All methods are transactional and thread-safe. Query methods follow
 * Spring Data naming conventions for automatic query generation.</p>
 *
 * @see User
 * @see JpaRepository
 */
public interface UserRepository extends JpaRepository<User, Long> {
    
    /**
     * Finds a user by their unique username.
     * 
     * <p>Query is case-sensitive. Returns empty Optional if no user found.</p>
     *
     * @param username the username to search for, must not be null or blank
     * @return Optional containing the user if found, empty otherwise
     */
    Optional<User> findByUsername(String username);
    
    /**
     * Checks if a user with the given email address exists.
     * 
     * <p>Email comparison is case-insensitive. More efficient than
     * findByEmail() when only existence check is needed.</p>
     *
     * @param email the email address to check, must not be null
     * @return true if a user with this email exists, false otherwise
     */
    boolean existsByEmail(String email);
    
    /**
     * Finds all users with the specified account status.
     * 
     * <p>Results are sorted by creation date descending (newest first).
     * May return empty list if no users match the status.</p>
     *
     * @param status the account status to filter by, must not be null
     * @return list of users with the given status, never null but may be empty
     */
    @Query("SELECT u FROM User u WHERE u.status = :status ORDER BY u.createdAt DESC")
    List<User> findAllByStatus(@Param("status") UserStatus status);
}
```

### 2. Controller Endpoint Documentation

**Generate for**: All REST endpoints

**Include**:
- Endpoint purpose and behavior
- Request/response formats
- HTTP status codes
- Authentication/authorization requirements
- Example requests

**Example**:
```java
/**
 * REST controller for user management operations.
 * 
 * <p>All endpoints require authentication. Admin endpoints require ADMIN role.</p>
 *
 * @see UserService
 */
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {
    private final UserService userService;
    
    /**
     * Creates a new user account.
     * 
     * <p><b>Endpoint:</b> POST /api/users</p>
     * <p><b>Authentication:</b> Not required (public registration)</p>
     * <p><b>Rate Limit:</b> 10 requests per hour per IP</p>
     * 
     * <p><b>Request Body Example:</b></p>
     * <pre>{@code
     * {
     *   "username": "johndoe",
     *   "email": "john@example.com",
     *   "password": "SecurePass123"
     * }
     * }</pre>
     *
     * <p><b>Response Codes:</b></p>
     * <ul>
     *   <li>201 Created - User successfully created</li>
     *   <li>400 Bad Request - Invalid request data</li>
     *   <li>409 Conflict - Username or email already exists</li>
     *   <li>429 Too Many Requests - Rate limit exceeded</li>
     * </ul>
     *
     * @param request the user creation request with validated data
     * @return ResponseEntity with created user (password excluded) and status 201
     * @throws DuplicateUserException if username or email already taken
     * @throws ValidationException if request validation fails
     */
    @PostMapping
    public ResponseEntity<UserDto> createUser(@Valid @RequestBody CreateUserRequest request) {
        User user = userService.createUser(request);
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(UserDto.from(user));
    }
    
    /**
     * Retrieves user by ID.
     * 
     * <p><b>Endpoint:</b> GET /api/users/{id}</p>
     * <p><b>Authentication:</b> Required</p>
     * <p><b>Authorization:</b> User can only access their own profile unless ADMIN</p>
     *
     * <p><b>Response Codes:</b></p>
     * <ul>
     *   <li>200 OK - User found and returned</li>
     *   <li>401 Unauthorized - Not authenticated</li>
     *   <li>403 Forbidden - Accessing other user's profile without ADMIN role</li>
     *   <li>404 Not Found - User does not exist</li>
     * </ul>
     *
     * @param id the user ID
     * @return ResponseEntity with user data and status 200
     * @throws UserNotFoundException if user with given ID does not exist
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or @securityService.isCurrentUser(#id)")
    public ResponseEntity<UserDto> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(UserDto.from(user));
    }
}
```

### 3. Complex Algorithm Documentation

**Generate for**: Methods with complex logic

**Include**:
- Algorithm description
- Complexity analysis (time/space)
- Assumptions and preconditions
- Edge cases

**Example**:
```java
/**
 * Calculates shipping cost based on order details using tiered pricing algorithm.
 * 
 * <p>Algorithm details:</p>
 * <ol>
 *   <li>Calculate base cost from weight and distance</li>
 *   <li>Apply volume discount (>10 items: 10% off, >50 items: 20% off)</li>
 *   <li>Add express shipping premium if requested</li>
 *   <li>Apply free shipping if total > $100</li>
 * </ol>
 *
 * <p><b>Time Complexity:</b> O(n) where n is number of items</p>
 * <p><b>Space Complexity:</b> O(1)</p>
 *
 * <p><b>Assumptions:</b></p>
 * <ul>
 *   <li>All items have positive weight</li>
 *   <li>Delivery address is valid</li>
 *   <li>Distance is in kilometers</li>
 * </ul>
 *
 * @param order the order containing items and delivery details, must not be null
 * @param expressShipping true if express shipping requested
 * @return shipping cost in USD, minimum $0.00
 * @throws IllegalArgumentException if order has no items or invalid address
 */
private BigDecimal calculateShippingCost(Order order, boolean expressShipping) {
    // Implementation with inline comments explaining key steps
}
```

### 4. Configuration Class Documentation

**Generate for**: @Configuration classes

**Include**:
- Purpose of configuration
- Beans provided
- Configuration properties used
- Dependencies

**Example**:
```java
/**
 * Database configuration for the application.
 * 
 * <p>Configures data source, JPA properties, and transaction management.
 * Supports multiple profiles: dev (H2), test (H2), prod (PostgreSQL).</p>
 *
 * <p>Configuration properties used:</p>
 * <ul>
 *   <li>spring.datasource.url - Database connection URL</li>
 *   <li>spring.datasource.username - Database user</li>
 *   <li>spring.datasource.password - Database password (from secrets)</li>
 *   <li>spring.jpa.hibernate.ddl-auto - Schema management strategy</li>
 * </ul>
 *
 * @see DataSource
 * @see EntityManagerFactory
 */
@Configuration
@EnableJpaRepositories(basePackages = "com.example.repository")
public class DatabaseConfig {
    
    /**
     * Creates and configures the application data source.
     * 
     * <p>Uses HikariCP connection pool with optimized settings for
     * high-throughput applications.</p>
     *
     * @return configured DataSource instance
     */
    @Bean
    public DataSource dataSource() {
        // Implementation
    }
}
```

### 5. Inline Comments for Complex Logic

**Add comments for**:
- Non-obvious business rules
- Workarounds for known issues
- Performance optimizations
- Security measures
- TODO items with context

**Example**:
```java
public void processPayment(Order order) {
    // Verify order has not been already processed to prevent double-charging
    if (order.getPaymentStatus() == PaymentStatus.COMPLETED) {
        log.warn("Attempted double payment for order {}", order.getId());
        throw new PaymentAlreadyProcessedException(order.getId());
    }
    
    // WORKAROUND: Payment gateway times out after 30 seconds
    // Split large transactions into multiple smaller ones
    // See JIRA-1234 for details
    if (order.getTotal().compareTo(new BigDecimal("10000")) > 0) {
        processLargePayment(order);
        return;
    }
    
    // Standard payment flow
    PaymentResult result = paymentGateway.charge(
        order.getPaymentMethod(),
        order.getTotal()
    );
    
    // Update order status atomically to prevent race conditions
    synchronized (this) {
        order.setPaymentStatus(PaymentStatus.COMPLETED);
        order.setPaymentId(result.getTransactionId());
        orderRepository.save(order);
    }
}
```

### 6. Package-level Documentation

**Generate**: package-info.java for major packages

**Example**:
```java
/**
 * User management service layer.
 * 
 * <p>This package contains service classes for user account management,
 * authentication, authorization, and profile operations.</p>
 *
 * <p>Key classes:</p>
 * <ul>
 *   <li>{@link com.example.service.UserService} - Main user management service</li>
 *   <li>{@link com.example.service.AuthService} - Authentication operations</li>
 *   <li>{@link com.example.service.ProfileService} - User profile management</li>
 * </ul>
 *
 * <p>All services are transactional and follow these conventions:</p>
 * <ul>
 *   <li>Use constructor injection for dependencies</li>
 *   <li>Annotated with {@code @Service}</li>
 *   <li>Methods throw specific exceptions, not generic ones</li>
 *   <li>Return domain objects, not entities directly</li>
 * </ul>
 *
 * @since 1.0.0
 */
package com.example.service;
```

## Output Format

### ⚠️ CRITICAL: JSON Output Requirements ⚠️

**READ**: `prompts/common/critical_json_requirements.md` for complete rules.

**Key Points**:
1. Output ONLY valid JSON, no other text
2. NO markdown code blocks (no ```json)
3. Include ALL required fields
4. Use exact field names and types
5. Validate before outputting

**Validation**: Your output will be validated against `schemas/review_result_schema.json`

### Required JSON Structure

```json
{
  "review_type": "DOCUMENTATION",
  "documentation": [
    {
      "file": "src/main/java/com/example/service/UserService.java",
      "line": 25,
      "type": "CLASS_JAVADOC",
      "generated_doc": "/**\n * Service for managing user accounts...\n */",
      "reason": "Public service class missing Javadoc"
    },
    {
      "file": "src/main/java/com/example/service/UserService.java",
      "line": 45,
      "type": "METHOD_JAVADOC",
      "generated_doc": "/**\n * Creates a new user account...\n * @param request...\n * @return...\n * @throws...\n */",
      "reason": "Public method missing complete Javadoc"
    },
    {
      "file": "src/main/java/com/example/service/OrderService.java",
      "line": 78,
      "type": "INLINE_COMMENT",
      "generated_doc": "// Workaround for payment gateway timeout issue (JIRA-1234)",
      "reason": "Complex workaround needs explanation"
    }
  ],
  "summary": {
    "total_additions": 3,
    "class_docs": 1,
    "method_docs": 1,
    "inline_comments": 1,
    "files_documented": 2
  },
  "commit_message": "docs: Add Javadoc for UserService and OrderService\n\n- Document UserService class and createUser method\n- Add inline comment explaining payment gateway workaround"
}
```

## Instructions

1. Analyze all public APIs in changed files
2. Generate comprehensive Javadoc following Java conventions
3. Add inline comments only where logic is non-obvious
4. Use {custom_rules} for project-specific documentation standards
5. Reference {jira_context} in TODO comments when relevant
6. Create git commit with generated documentation
7. Commit directly to MR source branch
8. Use meaningful commit message explaining what was documented
9. Output JSON with all generated documentation

## Commit Strategy

**Auto-commit documentation to source branch:**
- Commit message: "docs: Add documentation for [component names]"
- Include detailed description of what was documented
- Tag commit with [skip ci] to avoid triggering unnecessary builds
- Documentation commits do NOT require separate MR



