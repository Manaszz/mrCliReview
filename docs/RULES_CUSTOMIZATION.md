# Руководство по кастомизации правил

## Обзор

Система code review использует иерархическую систему правил, позволяющую кастомизацию на уровне проекта, команды и организации. Это руководство объясняет, как настроить правила под ваши специфические нужды.

---

## Иерархия приоритета правил

Правила загружаются в порядке приоритета (от высшего к низшему):

```
1. Правила конкретного проекта (.project-rules/ в репозитории)
   ↓
2. Правила Confluence (стандарты команды/организации)
   ↓
3. Правила по умолчанию (rules/java-spring-boot/)
```

**Поведение переопределения**: Правила с более высоким приоритетом полностью переопределяют правила с меньшим приоритетом для той же категории.

---

## Правила конкретного проекта

### Настройка

Создайте директорию `.project-rules/` в корне вашего репозитория:

```bash
cd your-project
mkdir .project-rules
```

### Структура

```
your-project/
├── .project-rules/
│   ├── error_detection.md
│   ├── best_practices.md
│   ├── security.md
│   ├── refactoring_criteria.md
│   ├── performance.md
│   └── README.md (опционально)
├── src/
├── pom.xml
└── README.md
```

### Создание пользовательских правил

Файлы пользовательских правил следуют тому же формату, что и правила по умолчанию.

**Пример**: `.project-rules/security.md`

```markdown
# Пользовательские правила безопасности для ProjectX

## Обзор
Дополнительные требования безопасности, специфичные для ProjectX, помимо стандартных правил.

---

## Правило 1: Аутентификация внутренних API

### Серьёзность: CRITICAL

### Описание
Все вызовы внутренних API должны включать наш пользовательский токен X-Internal-Auth.

### Паттерны для обнаружения

```java
// ПЛОХО: Отсутствует заголовок аутентификации
RestTemplate restTemplate = new RestTemplate();
ResponseEntity<String> response = restTemplate.getForEntity(
    "http://internal-api.company.com/users",
    String.class
);
```

### Правильный паттерн

```java
// ХОРОШО: Включён заголовок аутентификации
RestTemplate restTemplate = new RestTemplate();
HttpHeaders headers = new HttpHeaders();
headers.set("X-Internal-Auth", authTokenProvider.getToken());

HttpEntity<String> entity = new HttpEntity<>(headers);
ResponseEntity<String> response = restTemplate.exchange(
    "http://internal-api.company.com/users",
    HttpMethod.GET,
    entity,
    String.class
);
```

### Возможность автоисправления: Нет
```

---

## Правила Confluence

### Конфигурация

Правила Confluence загружаются через n8n workflow. Настройте в `.env`:

```env
CONFLUENCE_RULES_ENABLED=true
CONFLUENCE_SPACE_KEY=DEVSTD
CONFLUENCE_PAGE_ID=123456789
CONFLUENCE_CACHE_TTL=3600
```

### Структура страницы

Создайте страницу Confluence с такой структурой:

```markdown
# Стандарты разработки - Правила Code Review

## Java Spring Boot

### Обнаружение ошибок

[Содержимое правил обнаружения ошибок...]

### Лучшие практики

[Содержимое лучших практик...]

### Безопасность

[Правила безопасности...]
```

### n8n Workflow

n8n workflow:
1. Получает запрос на ревью
2. Проверяет кэш для правил Confluence (TTL 1 час)
3. Если не закэшировано, получает из Confluence REST API
4. Парсит markdown содержимое
5. Передаёт в review API как параметр `confluence_rules`

---

## Формат файлов правил

### Структура

```markdown
# Правила [Категория] для [Проект/Команда]

## Обзор
Краткое описание этих правил.

---

## Правило N: Название правила

### Серьёзность: CRITICAL | HIGH | MEDIUM | LOW

### Описание
Что проверяет это правило.

### Паттерны для обнаружения
Примеры кода, показывающие анти-паттерны (ПЛОХО).

### Правильный паттерн
Примеры кода, показывающие правильные паттерны (ХОРОШО).

### Возможность автоисправления: Да | Частично | Нет

### Ссылки (опционально)
Ссылки на документацию, внутреннюю wiki и т.д.

---
```

### Уровни серьёзности

- **CRITICAL**: Должно быть исправлено перед слиянием (блокирует MR)
- **HIGH**: Должно быть исправлено перед слиянием (строгая рекомендация)
- **MEDIUM**: Должно быть исправлено в ближайшее время (отслеживается)
- **LOW**: Улучшение "было бы неплохо"

---

## Распространённые сценарии кастомизации

### Сценарий 1: Корпоративный стандарт логирования

**Требование**: Все log statements должны использовать SLF4J с MDC для correlation IDs.

**Решение**: Создайте `.project-rules/best_practices.md`

```markdown
## Правило: Стандарты логирования

### Серьёзность: HIGH

### Описание
Всё логирование должно использовать SLF4J с MDC correlation IDs для распределённой трассировки.

### Паттерны для обнаружения

```java
// ПЛОХО: System.out
System.out.println("User logged in: " + userId);

// ПЛОХО: Log без MDC
log.info("User logged in: {}", userId);
```

### Правильный паттерн

```java
// ХОРОШО: SLF4J с MDC
MDC.put("correlationId", correlationIdProvider.get());
MDC.put("userId", userId);
log.info("User logged in");
MDC.clear();

// ЛУЧШЕ: Использовать try-with-resources паттерн
try (MDC.MDCCloseable mdc = MDC.putCloseable("correlationId", correlationId)) {
    log.info("User logged in: {}", userId);
}
```
```

---

### Сценарий 2: Более строгая изоляция транзакций

**Требование**: Все финансовые транзакции должны использовать изоляцию SERIALIZABLE.

**Решение**: Создайте `.project-rules/transaction_management.md`

```markdown
## Правило: Изоляция финансовых транзакций

### Серьёзность: CRITICAL

### Описание
Финансовые транзакции ДОЛЖНЫ использовать уровень изоляции SERIALIZABLE для предотвращения проблем с конкурентными изменениями.

### Паттерны для обнаружения

```java
// ПЛОХО: Изоляция по умолчанию для финансовой транзакции
@Transactional
public void transferFunds(Long fromId, Long toId, BigDecimal amount) {
    // ...
}
```

### Правильный паттерн

```java
// ХОРОШО: Изоляция SERIALIZABLE
@Transactional(isolation = Isolation.SERIALIZABLE)
public void transferFunds(Long fromId, Long toId, BigDecimal amount) {
    // ...
}
```

### Затронутые сервисы
- PaymentService
- AccountService
- TransactionService
```

---

### Сценарий 3: Обязательные аннотации владения кодом

**Требование**: Все сервисы должны иметь аннотацию @TeamOwner.

**Решение**: Создайте `.project-rules/best_practices.md`

```markdown
## Правило: Владение сервисом

### Серьёзность: MEDIUM

### Описание
Все классы @Service должны иметь аннотацию @TeamOwner для подотчётности.

### Паттерны для обнаружения

```java
// ПЛОХО: Отсутствует @TeamOwner
@Service
public class UserService {
    // ...
}
```

### Правильный паттерн

```java
// ХОРОШО: Есть @TeamOwner
@Service
@TeamOwner(team = "USER_MANAGEMENT_TEAM")
public class UserService {
    // ...
}
```

### Реализация

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface TeamOwner {
    String team();
}
```
```

---

### Сценарий 4: Ограничения размера рефакторинга

**Требование**: Любой рефакторинг, затрагивающий >5 файлов, должен быть в отдельном MR.

**Решение**: Создайте `.project-rules/refactoring_criteria.md`

```markdown
# Критерии классификации рефакторинга - ProjectX

## SIGNIFICANT рефакторинг (Требуется отдельный MR)

### Критерий 1: Scope - Затронуто более 5 классов

**Описание**: Рефакторинг затрагивает более 5 классов или файлов (строже чем по умолчанию).

**Обоснование**: Наша команда предпочитает меньшие, более сфокусированные MR для более простого ревью.
```

---

## Частичные переопределения

### Вариант 1: Полная замена
Поместите файл в `.project-rules/` чтобы полностью заменить правила по умолчанию.

### Вариант 2: Дополнительные правила
Используйте другое имя файла чтобы добавить правила без замены:

```
.project-rules/
├── security.md                    # Заменяет правила безопасности по умолчанию
└── custom_api_standards.md        # Дополнительные правила (ничего не заменяет)
```

**Примечание**: В настоящее время система загружает все `.md` файлы в `.project-rules/`. Чтобы добавить без замены, используйте уникальное имя файла, которое не совпадает с файлами правил по умолчанию.

---

## Тестирование пользовательских правил

### Локальное тестирование

1. **Создайте тестовый репозиторий**:
```bash
mkdir test-project
cd test-project
git init
mkdir .project-rules
```

2. **Добавьте пользовательское правило**:
```bash
cat > .project-rules/security.md << 'EOF'
# Пользовательские правила безопасности

## Правило 1: Тестовое правило
[содержимое правила]
EOF
```

3. **Создайте тестовый код**:
```bash
mkdir -p src/main/java/com/example
cat > src/main/java/com/example/Test.java << 'EOF'
public class Test {
    // Код, нарушающий ваше пользовательское правило
}
EOF
```

4. **Закоммитьте и запушьте**:
```bash
git add .
git commit -m "Test custom rules"
```

5. **Создайте MR и запустите ревью**:
- Система ревью обнаружит `.project-rules/` и использует ваши пользовательские правила

---

### Валидация

Проверьте, что пользовательские правила загружены:

1. **Логи Review API**:
```bash
docker logs review-api 2>&1 | grep "Loading custom rules"
```

Ожидаемый вывод:
```
2025-11-03 10:15:23 INFO Loading custom rules from .project-rules/
2025-11-03 10:15:23 INFO Found 3 custom rule files
2025-11-03 10:15:23 INFO Custom rules override default rules for: security, best_practices
```

2. **Результаты ревью**:
Проверьте, что проблемы ссылаются на ваши пользовательские правила:
```json
{
  "issues": [
    {
      "rule_source": "project_custom",
      "category": "Custom API Standards",
      ...
    }
  ]
}
```

---

## Лучшие практики

### 1. Начните с правил по умолчанию
Не переопределяйте правила без необходимости. Кастомизируйте только то, что действительно специфично для проекта.

### 2. Документируйте "почему"
Включайте обоснование для каждого пользовательского правила:
```markdown
### Обоснование
Мы используем этот паттерн потому что:
1. Наша инфраструктура требует его
2. Прошлые инциденты показали риск
3. Требование соответствия XYZ
```

### 3. Командное ревью
Перед коммитом пользовательских правил получите консенсус команды:
- Code review самих правил
- Тест на примерном коде
- Итерация на основе фидбека

### 4. Контроль версий
- Коммитьте `.project-rules/` в ваш репозиторий
- Отслеживайте изменения с осмысленными commit messages
- Тегируйте важные обновления правил

### 5. Поддерживайте актуальность
Просматривайте и обновляйте пользовательские правила когда:
- Меняются стандарты команды
- Приняты новые технологии
- Извлечены уроки из инцидентов

### 6. Ссылайтесь на документацию
Ссылайтесь на внутреннюю документацию:
```markdown
### Ссылки
- [Внутренняя Wiki: Стандарты логирования](https://wiki.company.com/logging)
- [Architecture Decision Record: ADR-023](https://wiki.company.com/adr/023)
```

---

## Руководство по миграции

### Миграция с ручного ревью

**Шаг 1**: Документируйте существующие стандарты
- Просмотрите прошлые комментарии к MR
- Извлеките общие паттерны фидбека
- Идентифицируйте повторяющиеся проблемы

**Шаг 2**: Создайте файлы правил
- Начните с проблем высокой серьёзности
- Добавьте примеры из реального кода
- Включите правильные паттерны

**Шаг 3**: Пилотное тестирование
- Протестируйте на недавних MR
- Сравните находки AI с ручным ревью
- Уточните правила на основе результатов

**Шаг 4**: Развёртывание в команде
- Задокументируйте пользовательские правила в README
- Обучите команду кастомизации правил
- Установите процесс обновления правил

---

## Устранение неполадок

### Проблема: Пользовательские правила не применяются

**Проверьте**:
1. Директория `.project-rules/` в корне репозитория?
2. Файлы названы правильно (например, `security.md`)?
3. Валидный markdown формат?
4. Файлы закоммичены и запушены в ветку, которая проверяется?

**Дебаг**:
```bash
# Проверьте, существует ли директория в клонированном репо
ls -la /tmp/review/project-{id}-mr-{iid}/.project-rules/

# Проверьте содержимое файла
cat /tmp/review/project-{id}-mr-{iid}/.project-rules/security.md
```

---

### Проблема: Конфликт правил с правилами по умолчанию

**Ожидаемое поведение**: Правила проекта полностью переопределяют правила по умолчанию для той же категории.

**Если видите и правила проекта, и правила по умолчанию**:
- Убедитесь, что имена файлов совпадают точно (регистрозависимые)
- Проверьте логику приоритетов CustomRulesLoader
- Проверьте отсутствие дублирующихся категорий в одном файле

---

### Проблема: Правила Confluence не загружаются

**Проверьте**:
1. `CONFLUENCE_RULES_ENABLED=true` в `.env`?
2. Учётные данные Confluence валидны?
3. Page ID правильный?
4. n8n workflow активен?

**Тест соединения Confluence**:
```bash
curl -u email@example.com:api_token \
  https://yourcompany.atlassian.net/wiki/rest/api/content/123456789?expand=body.storage
```

---

## Примеры

### Полный пример: Правила команды микросервисов

```markdown
# Правила Code Review команды UserService

## Обзор
Пользовательские правила для команды микросервиса UserService, применяющие паттерны, специфичные для сервиса.

---

## Правило 1: Доступ к данным пользователей

### Серьёзность: CRITICAL

### Описание
Весь доступ к данным пользователей должен проходить через UserRepository. Прямой доступ к БД запрещён.

### Паттерны для обнаружения
```java
// ПЛОХО: Прямой JDBC доступ
Connection conn = dataSource.getConnection();
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users WHERE id = ?");
```

### Правильный паттерн
```java
// ХОРОШО: Использовать репозиторий
User user = userRepository.findById(userId).orElseThrow();
```

---

## Правило 2: Логирование PII пользователей

### Серьёзность: CRITICAL

### Описание
Никогда не логируйте PII пользователей (email, телефон, адрес). Используйте только userId.

### Паттерны для обнаружения
```java
// ПЛОХО: Логирование email
log.info("User logged in: {}", user.getEmail());
```

### Правильный паттерн
```java
// ХОРОШО: Логировать только userId
log.info("User logged in: userId={}", user.getId());
```

---

## Правило 3: Переходы состояния пользователя

### Серьёзность: HIGH

### Описание
Изменения статуса пользователя должны проходить через UserStateMachine для обеспечения валидных переходов.

### Паттерны для обнаружения
```java
// ПЛОХО: Прямое изменение статуса
user.setStatus(UserStatus.SUSPENDED);
userRepository.save(user);
```

### Правильный паттерн
```java
// ХОРОШО: Использовать state machine
userStateMachine.transition(user, UserStatus.SUSPENDED);
```

---

## Контакты команды
- Владелец: @john.doe
- Slack: #user-service-team
- Wiki: https://wiki.company.com/teams/user-service
```

---

## Будущие улучшения

### Запланированные функции
1. **Шаблоны правил**: Переиспользуемые фрагменты правил
2. **Фреймворк тестирования правил**: Автоматизированное тестирование пользовательских правил
3. **Аналитика правил**: Отслеживание эффективности пользовательских правил
4. **Версионирование правил**: Поддержка нескольких версий правил для проекта
5. **Наследование правил**: Наследование от правил команды/организации с модификациями

---

## Ссылки

- [Документация правил по умолчанию](../rules/java-spring-boot/README.md)
- [Руководство по Prompts](PROMPTS_GUIDE.md)
- [Confluence REST API](https://developer.atlassian.com/cloud/confluence/rest/v1/)

---

**Последнее обновление**: 2025-11-03  
**Версия**: 2.0.0
